钩子函数、回调函数、注册函数，挂钩子这些我们代码中经常涉及到的东西，
是否已经困扰你很久了？它们究竟是怎么回事，究竟怎么用？下面我来为你一一解答。

什么是钩子函数？
钩子函数也叫回调函数，是通过函数指针来实现的，那我们来看看什么是函数指针。

首先看看以下例子：
int * p;
int a，b；
我们可以让指针p先后指向a, b，这样，p就先后代表了不同变量的地址
p = & a;
p = & b;
同样地，函数的指针可以指向不同的函数，从而完成不同的功能。
例如，定义函数指针：
int(*g_pFun)(int x, int y);
有两个函数：
/ *返回两个参数中的最大值 * /
int Max(intx, inty)
{}
/ *返回两个参数中的最小值 * /
int Min(int x, int y)
{}

int main(int argc, char * argv[])
{
    int r;

/ *我们让函数指针先后指向不同的函数 * /

   int a = 10;
   int b = 15;
   g_pFun = Max;
   r = g_pFun(a, b); / *相当于执行函数Max * /
   printf("%d\n", r);
   g_pFun = Min;
   r = g_pFun(a, b); / *相当于执行函数Min * /
   printf("%d\n", r);
   return 0;
}

分别输出：15, 10
这样，同样调用g_fun ，两次却完成不同的功能，神奇吧？这就是函数指针的妙用。
Max，Min函数就是钩子函数了，把函数指针g_pFun指向函数Max，Min的过程，就是“挂钩子”的过程，把钩子函数“挂”到函数指针上，很形象。
有人可能有疑问，那么这里为什么不直接调用Max和Min函数呢？
这是因为，我们在写main函数的时候，可能还不知道它会完成什么功能，
这时候留下函数指针作为接口，可以挂上不同的函数完成不同的功能，
究竟执行什么功能由钩子函数的编写者完成。

那我们平时怎么用的呢？
在我们的代码中，常常把挂钩子的过程叫做注册，会提供一个注册函数，
让使用者把自己编写的钩子函数挂在已经声明的函数指针上，
这个注册函数的参数就是我们的函数指针了，
比如，我们可以给刚才的函数指针提供一个注册函数：
int RegFun(int(*pFun)(int x, int y) )
 / *注册函数的参数是函数指针 * /
	{
		g_pFun = pFun;
		return 0;
	}
调用RegFun(Max)和RegFun(Min), 就可以把钩子函数挂上去了。
注意：为了便于使用，函数指针往往被声明为全局变量，
这也是刚才把函数指针的名字命名为g_pFun的原因。
下面我们来进行一下实战演习，
比如，平台部分要执行某一个操作，但是具体的操作还不确定，我们完成这样的代码：
int(*g_pFun)(int x, int y); / *函数指针 * /
int Plat()
	{
		int	r;
		int a = 10;
		int b = 15;
		r = g_pFun(a, b); / *这里要做一个操作，但是具体的操作还不确定 * /
		printf("%d\n", r);
		return 0;
	}
另外，平台部分再提供一个注册函数：
int RegFun(int(*pFun)(int x, int y))
	{
		g_pFun = pFun;
		return 0;
	}
应用模块完成具体的函数的功能：
intMax(intx, inty)
	{
		if (x > y)
			return x;
		else
			return y;
	}
int Min(int x, int y)
	{
		if (x < y)
			return x;
		else
			return y;
}
因为应用模块无法修改平台的代码，只能调用平台提供的注册函数：
如果应用模块注册：RegFun(Max),则运行main函数时，输出：15
如果应用模块注册：RegFun(Min),则运行main函数时，输出：10
这样，平台部分无需修改任何代码，只是应用模块注册了不同的钩子函数，
就能够完成不同的功能，这就是钩子函数的妙用。