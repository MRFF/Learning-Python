# 括号匹配问题
"""
思路：
成对的括号里左括号一定先出现，右括号匹配的一定是未匹配左括号里最后一个左括号（括号对向中间收束）
那么我们将建立一个栈，用来储存还未被匹配的左括号，每遇到一个右括号就看它与栈顶的左括号是否成对
是的话，就匹配成功一对，将栈顶压出，否则直接跳出，有一对匹配不成功，就说明其不合要求
重复上过程即可
遍历后，栈空则无错，未空则说明有错
"""

LEFT = {'(', '[', '{'}  # 左括号,对应的ASCII值  40 91 123
RIGHT = {')', ']', '}'}  # 右括号,对应的ASCII值 41 93 125


def match(expr):
    """
    :param expr:  传过来的字符串
    :return:  返回是否是正确的
    """
    stack = []  # 创建一个栈，用来存放未匹配的左括号
    for bracket in expr:  # 迭代传过来的所有字符串
        if brackets in LEFT:  # 如果当前字符在左括号内
            stack.append(brackets)  # 把当前左括号入栈
        elif brackets in RIGHT:  # 如果是右括号
            if not stack or not 1 <= ord(brackets) - ord(stack[-1]) <= 2:
                # 如果当前栈为空，()]
                # 如果右括号减去左括号的值不是小于等于2大于等于1
                return False  # 返回False
            stack.pop()  # 删除左括号
    return not stack  # 如果栈内没有值则返回True，否则返回False


# 迷宫问题
# 用一个二维数组表示一个简单的迷宫，用0表示通路，用1表示阻断，在每个点上可以移动相邻的东南西北四个点
# 模拟入口到出口的路径
"""
迷宫四周是墙
   0 1 2 3 4 5 6
   ---------
0  1 1 1 1 1 1 1
1  1 0 0 1 0 1 1
2  1 1 0 0 0 1 1
3  1 0 0 1 1 0 1
4  1 0 1 0 0 0 1
5  1 0 0 0 1 0 1
6  1 1 1 1 1 1 1
出路如下图所示
   0 1 2 3 4 5 6
   ---------
0  1 1 1 1 1 1 1
1  1 * * 1 0 1 1
2  1 1 * 0 0 1 1
3  1 * * 1 1 0 1
4  1 * 1 * * * 1
5  1 * * * 1 * 1
6  1 1 1 1 1 1 1
思路：
1.用一个栈来记录老鼠从入口到出口的路径
2.走到某点后，将该点左边压栈，并把该点值置为1，表示走过了；
3.从临近的四个点中可到达的点中任意选取一个，走到该点；
4.如果在到达某点后临近的4个点都不走，说明已经走入死胡同，此时退栈，退回一步尝试其他点；
反复执行第二、三、四步骤直到找到出口；
"""


# 生成一个7 * 7的迷宫
def init_maze():
    maze = [[0] * 7 for _ in range(7)]
    walls = [
        (1, 3),
        (2, 1), (2, 5),
        (3, 3), (3, 4),
        (4, 2),
        (5, 4)
    ]  # 墙的坐标
    for i in range(7):
        maze[0][i] = maze[-1][i] = 1  # 第一横行和最末横行都设置为墙
        maze[i][0] = maze[i][-1] = 1  # 第一竖行和最末竖行都设置为墙
    # 我原来写的方法，真是笨拙得可爱
    # for lst in maze:
    #     if maze.index(lst) == 0:
    #         maze[0] = [1] * 7
    #     elif maze.index(lst) == 6:
    #         maze[6] = [1] * 7
    #     else:
    #         lst[0] = 1
    #         lst[-1] = 1
    for i, j in walls:
        maze[i][j] = 1
    return maze


def find_path(maze, start, end):
    i, j = start  # 起始点坐标
    ei, ej = end  # 终止点坐标
    stack = [(i, j)]  # 栈是走过的路径，先将起始点放入其中
    while stack:
        i, j = stack[-1]
        if (i, j) == (ei, ej):
            break  # 走到了终点，则跳出while循环，说明已经找到了路径
        for di, dj in [(0, -1), (0, 1), (-1, 0), (1, 0)]:  # 左右上下四个方向
            if maze[i + di][j + dj] == 0:  # 只要四个方向中有点可走
                maze[i + di][j + dj] = 1  # 就把该点标志为1,表明探索过了，接下来就会尝试该点
                stack.append((i + di, j + dj))
                break  # 跳出当前for循环
        else:
            # 当迭代对象迭代完并为空时，else块才会被执行，上面如遇break会直接跳出for循环
            stack.pop()  # 如果所有点都不可走
    return stack


# 后缀表达式求值
"""
计算一个表达式时，编译器通常使用后缀表达式，这种表达式不需要括号
中缀表达式	                   后缀表达式
2 + 3 * 4	                   2 3 4 * +
( 1 + 2 ) * ( 6 / 3 ) + 2	   1 2 + 6 3 / * 2 +
18 / ( 3 * ( 1 + 2 ) )	       18 3 1 2 + * /
思路
1.建立一个栈来存储待计算的操作数；
2.遍历字符串，遇到操作数则压入栈中，遇到操作符号则出栈操作数(n次)，进行相应的计算，计算结果是新的操作数压回栈中，等待计算
3.按上述过程，遍历完整个表达式，栈中只剩下最终结果；
"""
